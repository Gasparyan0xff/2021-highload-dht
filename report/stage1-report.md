## Отчет №1 "HTTP Server"
## Автор: Гаспарян Сократ

### Проведите нагрузочное тестирование с помощью wrk в одно соединение PUT запросами.
На рисунке 1 и 2 представлены результаты нагрузочного тестирования PUT запросами в течение 2 минут с одним соединением, одним потоком и стабильной нагрузкой - rate равен 20000 запросов. Как видно из рисунков среднее время запроса составляет 7.39 сек., а пиковое время запроса 12.28 сек. Количество запросов 18092 в секунду, общее количество запросов составляет 2171221 запросов и общее количество переданного трафика составляет 138.78 Мб. Также стоит отметить, что на 75% запросов задержка составляет 10.63 сек, а на 99.99% 12.27 сек., что сильно отличается от среднего значения задержки.

<img src="resource/stage-1/stage-1-wrk-put1.jpg">Рис.1 нагрузка wrk PUT запросы часть 1</img>
<img src="resource/stage-1/stage-1-wrk-put2.jpg">Рис.2 нагрузка wrk PUT запросы часть 2</img>

### Профайлер для нагрузочного тестирования PUT запросов
Профилировка выполнялась в течение 15 секунд.
Как видно из рисунка 3 большая часть CPU уходит на обработку Http запроса(HttpServer.handleRequest) около 75% при этом 32% уходит на запись в сокет и 42% на запись в базу. Из этих 42% большая часть времени уходит на запись в файловую систему 32% (LsmDAO.flush). На рисунке 4 представлен отчет профайлера по памяти. Из рисунка видно, что большая часть использованной памяти идет на обработку запроса(handleParsedRequest) - 56% и из этих процентов большую часть занимает запись в базу(LsmDAO). Также 18% памяти уходит на парсинг самого запроса(HttpSession.parseRequest).

<img src="resource/stage-1/stage-1-profile-put-cpu.jpg">Рис.3 Flame Graph CPU async-profile для PUT запросов</img>
<img src="resource/stage-1/stage-1-profile-put-mem.jpg">Рис.4 Flame Graph Memory allocation async-profile для PUT запросов</img>

### Проведите нагрузочное тестирование с помощью wrk в одно соединение GET запросами.
На рисунке 5 и 6 представлены результаты нагрузочного тестирования GET запросами в течение 2 минут с одним соединением, одним потоком и стабильной нагрузкой - rate равен 20000 запросов. Как видно из рисунков среднее время запроса составляет 12.64 сек., а пиковое время запроса 25.89 сек. Количество запросов 15684 в секунду, общее количество запросов составляет 1882189 запросов и общее количество переданного трафика составляет 133.56 Мб. Также стоит отметить, что на 75% запросов задержка составляет 18.32 сек, а на 99.99% 25.9 сек. и скорость передаваемого трафика составляет 1.11 MB/s.

<img src="resource/stage-1/stage-1-wrk-get1.jpg">Рис.5 нагрузка wrk GET запросы часть 1</img>
<img src="resource/stage-1/stage-1-wrk-get2.jpg">Рис.6 нагрузка wrk GET запросы часть 2</img>

### Профайлер для нагрузочного тестирования GET запросов
Профилировка выполнялась в течение 15 секунд.
На рисунке 7 видно, что большую часть времени занимает метод считывания из базы(LsmDAO.range) - 48.7%. При этом от момента принятия HTTP запроса до момента запроса в базу разница в загрузке CPU составляет 10.82%. Ещё 22.68% занимает процесс записи данных в сокет. Профилировка по памяти показывает, что наибольшее количество памяти 65.49% занимает метод извлечения данных из базы - LsmDAO.sstableRange, в этом методе есть наиболее требовательных вызова по памяти - LsmDAO.merge 32.26% и SSTable.range 31.3%.
<img src="resource/stage-1/stage-1-profile-get-cpu.jpg">Рис.7 Flame Graph CPU async-profile для GET запросов</img>
<img src="resource/stage-1/stage-1-profile-get-mem.jpg">Рис.8 Flame Graph Memory allocation async-profile для GET запросов</img>